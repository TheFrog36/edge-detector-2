Fast blur algorithm
// source channel, target channel, width, height, radius
    function gaussBlur_4 (scl, tcl, w, h, r) {
        var bxs = boxesForGauss(r, 3);
        boxBlur_4 (scl, tcl, w, h, (bxs[0]-1)/2);
        boxBlur_4 (tcl, scl, w, h, (bxs[1]-1)/2);
        boxBlur_4 (scl, tcl, w, h, (bxs[2]-1)/2);
    }
    function boxBlur_4 (scl, tcl, w, h, r) {
        for(var i=0; i<scl.length; i++) tcl[i] = scl[i];
        boxBlurH_4(tcl, scl, w, h, r);
        boxBlurT_4(scl, tcl, w, h, r);
    }
    function boxBlurH_4 (scl, tcl, w, h, r) {
        var iarr = 1 / (r+r+1);
        for(var i=0; i<h; i++) {
            var ti = i*w, li = ti, ri = ti+r;
            var fv = scl[ti], lv = scl[ti+w-1], val = (r+1)*fv;
            for(var j=0; j<r; j++) val += scl[ti+j];
            for(var j=0  ; j<=r ; j++) { val += scl[ri++] - fv       ;   tcl[ti++] = Math.round(val*iarr); }
            for(var j=r+1; j<w-r; j++) { val += scl[ri++] - scl[li++];   tcl[ti++] = Math.round(val*iarr); }
            for(var j=w-r; j<w  ; j++) { val += lv        - scl[li++];   tcl[ti++] = Math.round(val*iarr); }
        }
    }
    function boxBlurT_4 (scl, tcl, w, h, r) {
        var iarr = 1 / (r+r+1);
        for(var i=0; i<w; i++) {
            var ti = i, li = ti, ri = ti+r*w;
            var fv = scl[ti], lv = scl[ti+w*(h-1)], val = (r+1)*fv;
            for(var j=0; j<r; j++) val += scl[ti+j*w];
            for(var j=0  ; j<=r ; j++) { val += scl[ri] - fv     ;  tcl[ti] = Math.round(val*iarr);  ri+=w; ti+=w; }
            for(var j=r+1; j<h-r; j++) { val += scl[ri] - scl[li];  tcl[ti] = Math.round(val*iarr);  li+=w; ri+=w; ti+=w; }
            for(var j=h-r; j<h  ; j++) { val += lv      - scl[li];  tcl[ti] = Math.round(val*iarr);  li+=w; ti+=w; }
        }
    }

------------------------------------------------------------

js conversion

function gaussBlur_4(scl, tcl, w, h, r) {
    var bxs = boxesForGauss(r, 3);
    boxBlur_4(scl, tcl, w, h, (bxs[0] - 1) / 2);
    boxBlur_4(tcl, scl, w, h, (bxs[1] - 1) / 2);
    boxBlur_4(scl, tcl, w, h, (bxs[2] - 1) / 2);
}

function boxBlur_4(scl, tcl, w, h, r) {
    for (var i = 0; i < scl.length; i++) {
        tcl[i] = scl[i];
    }
    boxBlurH_4(tcl, scl, w, h, r);
    boxBlurT_4(scl, tcl, w, h, r);
}

function boxBlurH_4(scl, tcl, w, h, r) {
    var iarr = 1 / (r + r + 1);
    for (var i = 0; i < h; i++) {
        var ti = i * w, li = ti, ri = ti + r;
        var fv = scl[ti], lv = scl[ti + w - 1], val = (r + 1) * fv;

        for (var j = 0; j < r; j++) val += scl[ti + j];
        
        for (var j = 0; j <= r; j++) {
            val += scl[ri++] - fv;
            tcl[ti++] = Math.round(val * iarr);
        }
        
        for (var j = r + 1; j < w - r; j++) {
            val += scl[ri++] - scl[li++];
            tcl[ti++] = Math.round(val * iarr);
        }
        
        for (var j = w - r; j < w; j++) {
            val += lv - scl[li++];
            tcl[ti++] = Math.round(val * iarr);
        }
    }
}

function boxBlurT_4(scl, tcl, w, h, r) {
    var iarr = 1 / (r + r + 1);
    for (var i = 0; i < w; i++) {
        var ti = i, li = ti, ri = ti + r * w;
        var fv = scl[ti], lv = scl[ti + w * (h - 1)], val = (r + 1) * fv;

        for (var j = 0; j < r; j++) val += scl[ti + j * w];

        for (var j = 0; j <= r; j++) {
            val += scl[ri] - fv;
            tcl[ti] = Math.round(val * iarr);
            ri += w;
            ti += w;
        }

        for (var j = r + 1; j < h - r; j++) {
            val += scl[ri] - scl[li];
            tcl[ti] = Math.round(val * iarr);
            li += w;
            ri += w;
            ti += w;
        }

        for (var j = h - r; j < h; j++) {
            val += lv - scl[li];
            tcl[ti] = Math.round(val * iarr);
            li += w;
            ti += w;
        }
    }
}

function boxesForGauss(r, n) {
    // This function is not defined in the original code.
    // Here's a simple approximation for the "boxes for gauss" function.
    var boxes = [];
    for (var i = 0; i < n; i++) {
        boxes.push(r);
    }
    return boxes;
}

------------------------------------------------------------

Fast algorithm 
void fastblur(Bitmap img, int radius){

    if (radius<1){
        return;
    }
    int w= img.getWidth();
    int h=img.getHeight();
    int wm=w-1;
    int hm=h-1;
    int wh=w*h;
    int div=radius+radius+1;
    int r[]=new int[wh];
    int g[]=new int[wh];
    int b[]=new int[wh];
    int rsum,gsum,bsum,x,y,i,p,p1,p2,yp,yi,yw;
    int vmin[] = new int[Math.max(w,h)];
    int vmax[] = new int[Math.max(w,h)];
    int[] pix= new  int[w*h];
    img.getPixels(pix, 0, w, 0,0,w, h);
    int dv[]=new int[256*div];
    for (i=0;i<256*div;i++){
        dv[i]=(i/div);
    }
    yw=yi=0;

    for (y=0;y<h;y++){
        rsum=gsum=bsum=0;
        for(i=-radius;i<=radius;i++){
            p=pix[yi+Math.min(wm,Math.max(i,0))];
            rsum+=(p & 0xff0000)>>16;
            gsum+=(p & 0x00ff00)>>8;
            bsum+= p & 0x0000ff;
        }
        for (x=0;x<w;x++){
            r[yi]=dv[rsum];
            g[yi]=dv[gsum];
            b[yi]=dv[bsum];

            if(y==0){
                vmin[x]=Math.min(x+radius+1,wm);
                vmax[x]=Math.max(x-radius,0);
            }
            p1=pix[yw+vmin[x]];
            p2=pix[yw+vmax[x]];

            rsum+=((p1 & 0xff0000)-(p2 & 0xff0000))>>16;
            gsum+=((p1 & 0x00ff00)-(p2 & 0x00ff00))>>8;
            bsum+= (p1 & 0x0000ff)-(p2 & 0x0000ff);
            yi++;
        }
        yw+=w;
    }
    for (x=0;x<w;x++){
        rsum=gsum=bsum=0;
        yp=-radius*w;
        for(i=-radius;i<=radius;i++){
            yi=Math.max(0,yp)+x;
            rsum+=r[yi];
            gsum+=g[yi];
            bsum+=b[yi];
            yp+=w;
        }
        yi=x;
        for (y=0;y<h;y++){
            pix[yi]=0xff000000 | (dv[rsum]<<16) | (dv[gsum]<<8) | dv[bsum];
            if(x==0){
                vmin[y]=Math.min(y+radius+1,hm)*w;
                vmax[y]=Math.max(y-radius,0)*w;
            }
            p1=x+vmin[y];
            p2=x+vmax[y];

            rsum+=r[p1]-r[p2];
            gsum+=g[p1]-g[p2];
            bsum+=b[p1]-b[p2];

            yi+=w;
        }
    }
    img.setPixels(pix,0, w,0,0,w,h);
}




----------------------------------------
function fastblur(canvas, radius) {
    if (radius < 1) {
        return;
    }

    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;
    const wm = w - 1;
    const hm = h - 1;
    const wh = w * h;
    const div = radius + radius + 1;
    const r = new Array(wh);
    const g = new Array(wh);
    const b = new Array(wh);
    const dv = new Array(256 * div);
    const vmin = new Array(Math.max(w, h));
    const vmax = new Array(Math.max(w, h));
    const pix = new Array(wh);

    // Get the pixel data from the canvas
    const imgData = ctx.getImageData(0, 0, w, h);
    const data = imgData.data;

    // Precompute the dv array
    for (let i = 0; i < 256 * div; i++) {
        dv[i] = Math.floor(i / div);
    }

    let yw = 0;
    let yi = 0;

    // Horizontal pass
    for (let y = 0; y < h; y++) {
        let rsum = 0, gsum = 0, bsum = 0;

        // Initialize the sum for the first radius
        for (let i = -radius; i <= radius; i++) {
            const p = data[yi + Math.min(wm, Math.max(i, 0)) * 4];
            rsum += (p & 0xff0000) >> 16;
            gsum += (p & 0x00ff00) >> 8;
            bsum += p & 0x0000ff;
        }

        for (let x = 0; x < w; x++) {
            // Store the average value for the current pixel
            r[yi] = dv[rsum];
            g[yi] = dv[gsum];
            b[yi] = dv[bsum];

            if (y === 0) {
                vmin[x] = Math.min(x + radius + 1, wm);
                vmax[x] = Math.max(x - radius, 0);
            }

            const p1 = data[yw + vmin[x] * 4];
            const p2 = data[yw + vmax[x] * 4];

            // Update the sums by subtracting the left-most and adding the right-most
            rsum += ((p1 & 0xff0000) - (p2 & 0xff0000)) >> 16;
            gsum += ((p1 & 0x00ff00) - (p2 & 0x00ff00)) >> 8;
            bsum += (p1 & 0x0000ff) - (p2 & 0x0000ff);

            yi++;
        }

        yw += w;
    }

    // Vertical pass
    for (let x = 0; x < w; x++) {
        let rsum = 0, gsum = 0, bsum = 0;
        let yp = -radius * w;

        // Initialize the sum for the first radius
        for (let i = -radius; i <= radius; i++) {
            yi = Math.max(0, yp) + x;
            rsum += r[yi];
            gsum += g[yi];
            bsum += b[yi];
            yp += w;
        }

        yi = x;

        for (let y = 0; y < h; y++) {
            // Set the final pixel values
            const index = yi * 4;
            data[index] = 0xff000000 | (dv[rsum] << 16) | (dv[gsum] << 8) | dv[bsum];

            if (x === 0) {
                vmin[y] = Math.min(y + radius + 1, hm) * w;
                vmax[y] = Math.max(y - radius, 0) * w;
            }

            const p1 = x + vmin[y];
            const p2 = x + vmax[y];

            // Update the sums by subtracting the top-most and adding the bottom-most
            rsum += r[p1] - r[p2];
            gsum += g[p1] - g[p2];
            bsum += b[p1] - b[p2];

            yi += w;
        }
    }

    // Put the processed pixel data back onto the canvas
    ctx.putImageData(imgData, 0, 0);
}
